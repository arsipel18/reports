/**
 * Data Adapter to transform ReportCreator output to PNG renderer input
 * This bridges the gap between the data structure generated by ReportCreator
 * and what the fancy PNG renderer expects
 */

/**
 * Transform ReportCreator data to PNG renderer format
 * @param {Object} reportCreatorData - Data from ReportCreator.generateReport()
 * @returns {Object} Data formatted for PNG renderer
 */
export function adaptReportDataForPNG(reportCreatorData) {
  const {
    period,
    timeRange,
    summary,
    categories,
    sentiments,
    topPosts,
    top2EngagedPosts, // Get the top 2 engaged posts for PNG
    top5ModeratorCommenters, // Get moderator data
    commentExamples,
    moderatorAnalysis,
    filters,
    posts = [], // Raw posts data if available
    allPosts = [] // Full posts dataset for timeseries (unfiltered)
  } = reportCreatorData;

  // Generate missing timeseries data
  // Always use allPosts for timeseries to show overall activity trend
  // Only filter the summary data, not the trend chart
  const timeseries = generateTimeseriesData(allPosts.length > 0 ? allPosts : posts, period);
  
  // Generate missing category series data
  const categorySeries = generateCategorySeriesData(posts, categories, period);
  
  // Generate missing score histogram
  const scoreHistogram = generateScoreHistogram(posts);
  
  // Generate missing moderator series data
  const moderatorSeries = generateModeratorSeriesData(posts, period);
  
  // Generate missing keywords data
  const keywords = generateKeywordsData(posts);
  
  // Generate missing categories sentiment data
  const categoriesSentiment = generateCategoriesSentimentData(posts, categories);

  // Format moderator data for PNG renderer
  const formattedModeratorAnalysis = {
    ...moderatorAnalysis,
    topModerators: top5ModeratorCommenters?.map(mod => ({
      username: mod.moderator_username,
      postsHandled: mod.posts_handled,
      avgScore: Math.round(mod.avg_comment_score),
      totalComments: mod.total_comments,
      avgResponseTime: mod.avg_response_time_minutes
    })) || []
  };

  return {
    period,
    timeRange,
    summary,
    categories,
    sentiments,
    categoriesSentiment,
    topPosts: top2EngagedPosts || topPosts, // Use top2EngagedPosts if available, fallback to topPosts
    commentExamples,
    moderatorAnalysis: formattedModeratorAnalysis,
    keywords,
    timeseries,
    categorySeries,
    scoreHistogram,
    moderatorSeries,
    filters
  };
}

/**
 * Generate timeseries data from posts
 */
function generateTimeseriesData(posts, period) {
  if (!posts || posts.length === 0) {
    // For filtered reports with no data, return empty arrays to indicate no data
    // The chart will handle this gracefully
    return {
      posts: [],
      comments: [],
      labels: [],
      calendar: []
    };
  }

  // Get actual date range from posts data
  const postDates = posts.map(post => new Date(post.created_utc * 1000));
  const minDate = new Date(Math.min(...postDates));
  const maxDate = new Date(Math.max(...postDates));
  
  // Generate days array based on actual data range
  const days = generateDaysFromRange(minDate, maxDate, period);
  
  const postsPerDay = new Array(days.length).fill(0);
  const commentsPerDay = new Array(days.length).fill(0);
  
  // Group posts by appropriate time period
  posts.forEach(post => {
    const postDate = new Date(post.created_utc * 1000);
    const dayIndex = getDayIndexForPeriod(postDate, days, period);
    if (dayIndex >= 0) {
      postsPerDay[dayIndex]++;
      commentsPerDay[dayIndex] += post.num_comments || 0;
    }
  });

  // For quarterly and yearly, we need to adjust the scale
  // Since we're grouping daily data into weeks/months, we should show totals, not averages
  if (period === 'quarterly' || period === 'yearly') {
    // Keep the data as totals (posts per week/month)
    // The chart will handle the scaling appropriately
  }

  // Generate calendar data (last 35 days)
  const calendarData = generateCalendarData(posts, 35);

  return {
    posts: postsPerDay,
    comments: commentsPerDay,
    labels: generateLabelsForPeriod(days, period),
    calendar: calendarData
  };
}

/**
 * Generate category series data
 */
function generateCategorySeriesData(posts, categories, period) {
  if (!posts || posts.length === 0 || !categories || categories.length === 0) {
    return {};
  }

  // Get actual date range from posts data
  const postDates = posts.map(post => new Date(post.created_utc * 1000));
  const minDate = new Date(Math.min(...postDates));
  const maxDate = new Date(Math.max(...postDates));
  
  // Generate days array based on actual data range
  const days = generateDaysFromRange(minDate, maxDate, period);
  
  const categorySeries = {};

  categories.slice(0, 6).forEach(cat => {
    const categoryName = cat.category || cat.name;
    categorySeries[categoryName] = new Array(days.length).fill(0);
  });

  // Group posts by category and day
  posts.forEach(post => {
    const category = post.category;
    const postDate = new Date(post.created_utc * 1000);
    const dayIndex = getDayIndexForPeriod(postDate, days, period);
    
    if (category && categorySeries[category] && dayIndex >= 0) {
      categorySeries[category][dayIndex]++;
    }
  });

  return categorySeries;
}

/**
 * Generate score histogram data
 */
function generateScoreHistogram(posts) {
  if (!posts || posts.length === 0) {
    return new Array(10).fill(0);
  }

  const scores = posts.map(p => p.score || 0);
  const maxScore = Math.max(...scores);
  const bins = new Array(10).fill(0);

  if (maxScore === 0) return bins;

  scores.forEach(score => {
    const binIndex = Math.min(9, Math.floor((score / maxScore) * 10));
    bins[binIndex]++;
  });

  return bins;
}

/**
 * Generate moderator series data
 */
function generateModeratorSeriesData(posts, period) {
  if (!posts || posts.length === 0) {
    return [];
  }

  // Get actual date range from posts data
  const postDates = posts.map(post => new Date(post.created_utc * 1000));
  const minDate = new Date(Math.min(...postDates));
  const maxDate = new Date(Math.max(...postDates));
  
  // Generate days array based on actual data range
  const days = generateDaysFromRange(minDate, maxDate, period);
  
  const moderatorActivity = new Array(days.length).fill(0);

  // This is a simplified approach - in reality you'd need to track moderator responses
  // For now, we'll generate some mock data based on post activity
  posts.forEach(post => {
    const postDate = new Date(post.created_utc * 1000);
    const dayIndex = getDayIndexForPeriod(postDate, days, period);
    
    if (dayIndex >= 0 && post.num_comments > 5) {
      // Assume higher comment activity correlates with more moderator involvement
      moderatorActivity[dayIndex] += Math.min(3, Math.floor(post.num_comments / 10));
    }
  });

  return moderatorActivity;
}

/**
 * Generate keywords data from post titles and bodies
 */
function generateKeywordsData(posts) {
  if (!posts || posts.length === 0) {
    return [];
  }

  const wordCount = {};
  const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them']);

  posts.forEach(post => {
    const text = `${post.title || ''} ${post.body || ''}`.toLowerCase();
    const words = text.match(/\b\w+\b/g) || [];
    
    words.forEach(word => {
      if (word.length > 3 && !stopWords.has(word)) {
        wordCount[word] = (wordCount[word] || 0) + 1;
      }
    });
  });

  return Object.entries(wordCount)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 20)
    .map(([label, count]) => ({
      label,
      weight: Math.min(1, count / Math.max(...Object.values(wordCount)))
    }));
}

/**
 * Generate categories sentiment data
 */
function generateCategoriesSentimentData(posts, categories) {
  if (!posts || posts.length === 0 || !categories || categories.length === 0) {
    return [];
  }

  const categorySentiment = {};

  // Initialize categories
  categories.forEach(cat => {
    const categoryName = cat.category || cat.name;
    categorySentiment[categoryName] = { pos: 0, neu: 0, neg: 0, count: 0 };
  });

  // Count sentiments by category
  posts.forEach(post => {
    const category = post.category;
    const sentiment = post.sentiment;
    
    if (category && categorySentiment[category]) {
      categorySentiment[category].count++;
      if (sentiment === 'pos') categorySentiment[category].pos++;
      else if (sentiment === 'neg') categorySentiment[category].neg++;
      else categorySentiment[category].neu++;
    }
  });

  // Convert to array format
  return Object.entries(categorySentiment)
    .map(([category, data]) => ({
      category,
      pos: data.pos,
      neu: data.neu,
      neg: data.neg,
      count: data.count
    }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 6);
}

/**
 * Generate calendar data for heatmap
 */
function generateCalendarData(posts, days) {
  const calendarData = new Array(days).fill(0);
  const now = new Date();
  
  posts.forEach(post => {
    const postDate = new Date(post.created_utc * 1000);
    const daysAgo = Math.floor((now - postDate) / (1000 * 60 * 60 * 24));
    
    if (daysAgo >= 0 && daysAgo < days) {
      calendarData[days - 1 - daysAgo]++;
    }
  });

  return calendarData;
}

/**
 * Generate days array from actual data range with appropriate grouping
 */
function generateDaysFromRange(minDate, maxDate, period) {
  const days = [];
  
  // Add some padding to show context, but not too much
  const paddedMinDate = new Date(minDate);
  const paddedMaxDate = new Date(maxDate);
  
  // Add small padding based on period
  switch (period) {
    case 'daily':
    case 'weekly':
      paddedMinDate.setDate(paddedMinDate.getDate() - 1);
      paddedMaxDate.setDate(paddedMaxDate.getDate() + 1);
      break;
    case 'monthly':
      paddedMinDate.setDate(paddedMinDate.getDate() - 2);
      paddedMaxDate.setDate(paddedMaxDate.getDate() + 2);
      break;
    case 'quarterly':
      paddedMinDate.setDate(paddedMinDate.getDate() - 7); // Week padding
      paddedMaxDate.setDate(paddedMaxDate.getDate() + 7);
      break;
    case 'yearly':
      paddedMinDate.setMonth(paddedMinDate.getMonth() - 1);
      paddedMaxDate.setMonth(paddedMaxDate.getMonth() + 1);
      // Ensure we don't go beyond reasonable bounds
      if (paddedMinDate.getMonth() < 0) {
        paddedMinDate.setMonth(0);
      }
      if (paddedMaxDate.getMonth() > 11) {
        paddedMaxDate.setMonth(11);
      }
      break;
  }
  
  // Generate appropriate intervals based on period
  switch (period) {
    case 'daily':
      // For daily reports, show 3-hour intervals for the last 24 hours
      const currentHour = new Date(paddedMinDate);
      // Round to the nearest 3-hour mark (0, 3, 6, 9, 12, 15, 18, 21)
      const hour = currentHour.getHours();
      const roundedHour = Math.floor(hour / 3) * 3;
      currentHour.setHours(roundedHour, 0, 0, 0);
      
      // Generate 3-hour intervals for the last 24 hours (8 intervals)
      for (let i = 0; i < 8; i++) {
        days.push(new Date(currentHour));
        currentHour.setHours(currentHour.getHours() + 3);
      }
      break;
      
    case 'quarterly':
      // For quarterly, group by weeks (7-day intervals)
      const currentWeek = new Date(paddedMinDate);
      // Start from beginning of week
      currentWeek.setDate(currentWeek.getDate() - currentWeek.getDay());
      
      while (currentWeek <= paddedMaxDate) {
        days.push(new Date(currentWeek));
        currentWeek.setDate(currentWeek.getDate() + 7); // Move to next week
      }
      break;
      
    case 'yearly':
      // For yearly, group by months
      const currentMonth = new Date(paddedMinDate);
      currentMonth.setDate(1); // Start of month
      
      let monthCount = 0;
      const maxMonths = 24; // Maximum 24 months to prevent overcrowding
      
      // Ensure we don't exceed the padded max date
      while (currentMonth <= paddedMaxDate && monthCount < maxMonths) {
        days.push(new Date(currentMonth));
        currentMonth.setMonth(currentMonth.getMonth() + 1);
        monthCount++;
        // Prevent infinite loop
        if (currentMonth.getMonth() === 0 && currentMonth.getFullYear() > paddedMaxDate.getFullYear()) {
          break;
        }
      }
      break;
      
    default:
      // For weekly/monthly, use daily granularity
      const currentDate = new Date(paddedMinDate);
      while (currentDate <= paddedMaxDate) {
        days.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
      }
      break;
  }
  
  return days;
}

/**
 * Get days array for period (legacy function)
 */
function getDaysForPeriod(period) {
  const now = new Date();
  const days = [];
  
  let dayCount;
  switch (period) {
    case 'daily':
      dayCount = 7; // Show last 7 days
      break;
    case 'weekly':
      dayCount = 7; // Show last 7 days
      break;
    case 'monthly':
      dayCount = 30; // Show last 30 days
      break;
    case 'quarterly':
      dayCount = 12; // Show 12 weeks (3 months)
      break;
    case 'yearly':
      dayCount = 12; // Show 12 months
      break;
    default:
      dayCount = 7;
  }

  for (let i = dayCount - 1; i >= 0; i--) {
    const day = new Date(now);
    if (period === 'quarterly') {
      // For quarterly, group by weeks
      day.setDate(day.getDate() - (i * 7));
    } else if (period === 'yearly') {
      // For yearly, group by months
      day.setMonth(day.getMonth() - i);
    } else {
      // For daily/weekly/monthly, use daily granularity
      day.setDate(day.getDate() - i);
    }
    days.push(day);
  }

  return days;
}

/**
 * Generate appropriate labels for different periods
 */
function generateLabelsForPeriod(days, period) {
  switch (period) {
    case 'daily':
      // For daily reports, show 3-hour time labels (00:00, 03:00, 06:00, etc.)
      return days.map(day => {
        const hour = day.getHours();
        return `${hour.toString().padStart(2, '0')}:00`;
      });
    
    case 'weekly':
      // For weekly, show weekday names
      return days.map(day => day.toLocaleDateString('en-US', { weekday: 'short' }));
    
    case 'monthly':
      // For monthly, show day numbers (1, 2, 3, etc.)
      return days.map(day => day.getDate().toString());
    
    case 'quarterly':
      // For quarterly, show week labels (Week 1, Week 2, etc.)
      return days.map((day, index) => `W${index + 1}`);
    
    case 'yearly':
      // For yearly, show month names (Jan, Feb, Mar, etc.)
      return days.map(day => day.toLocaleDateString('en-US', { month: 'short' }));
    
    default:
      // Fallback to weekday names
      return days.map(day => day.toLocaleDateString('en-US', { weekday: 'short' }));
  }
}

/**
 * Get day index for a given date based on period
 */
function getDayIndexForPeriod(date, days, period) {
  switch (period) {
    case 'daily':
      // For daily reports, group by 3-hour intervals
      const hour = date.getHours();
      const roundedHour = Math.floor(hour / 3) * 3;
      const roundedDate = new Date(date);
      roundedDate.setHours(roundedHour, 0, 0, 0);
      
      return days.findIndex(day => {
        const dayHour = day.getHours();
        const dayRoundedHour = Math.floor(dayHour / 3) * 3;
        const dayRoundedDate = new Date(day);
        dayRoundedDate.setHours(dayRoundedHour, 0, 0, 0);
        
        return dayRoundedDate.getTime() === roundedDate.getTime();
      });
    
    case 'quarterly':
      // For quarterly, group by weeks - find which week this date belongs to
      const weekStart = new Date(date);
      weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // Start of week
      return days.findIndex(day => {
        const dayWeekStart = new Date(day);
        dayWeekStart.setDate(dayWeekStart.getDate() - dayWeekStart.getDay());
        return dayWeekStart.toDateString() === weekStart.toDateString();
      });
    
    case 'yearly':
      // For yearly, group by months
      return days.findIndex(day => 
        day.getMonth() === date.getMonth() && day.getFullYear() === date.getFullYear()
      );
    
    default:
      // For weekly/monthly, use exact date matching
      return days.findIndex(day => day.toDateString() === date.toDateString());
  }
}

/**
 * Get day index for a given date (legacy function)
 */
function getDayIndex(date, days) {
  const dateStr = date.toDateString();
  return days.findIndex(day => day.toDateString() === dateStr);
}
